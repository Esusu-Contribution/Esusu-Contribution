{
  "language": "Solidity",
  "sources": {
    "contracts/Esusu.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20Token {\n    function transfer(address, uint256) external returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function totalSupply() external view  returns (uint256);\n    function balanceOf(address) external view  returns (uint256);\n    function allowance(address, address) external view  returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Esusu {\n   \n\n    uint public number_of_deposits;\n    uint256 public txHistoryLen;\n    uint256 public savinsLen;\n    // address of the child\n    address payable public childAddress;\n    uint256 public  currentTimeStap = block.timestamp;\n    // to confirm the child is above or already 18 years with conversion of the block timestamp\n    uint256 toGetPay = currentTimeStap + 18 * 365 * 24 * 60 * 60;\n\n \n\n    event Received(address sender, uint256 amount);\n\n    \n    struct ChildSavings {\n        uint256 childAge;\n        uint256 amount;\n        uint256 targetChild;\n        address payable childAddress;\n        address fatherAddress;\n        uint256 canWithdraw;\n        bool deposited;\n    }\n\n    struct TxHistory {\n        uint256 savingsNonce;\n        string purpose;\n        uint256 amount;\n        address payable owner;\n        uint256 totalDeposit;\n        uint256 time;\n\n    }\n\n    modifier onlYowner(address owner) {\n        require(msg.sender == owner, \"Only the owner\");\n        _;\n    }\n\n    mapping (address => ChildSavings) public _childSavings;\n    // mapping (address => TxHistory) public _txHistory;\n    mapping(uint256 => mapping(address => TxHistory)) public _txHistory;\n\n\n    constructor() {\n        \n    }\n\n\n    function withdraw(address _child) external {\n        require(msg.sender == _childSavings[msg.sender].childAddress, \"cant withdraw fund because its not child address\" );\n        // require(!_childSavings[_child].childAddress, \"cant withdraw fund because its not child address\" );\n        \n        ChildSavings storage savings = _childSavings[msg.sender];\n        require(savings.targetChild >= savings.amount, \"Not yet target\");\n        uint256 amount = _childSavings[_child].amount;\n\n\n        (bool sent, ) = payable(savings.childAddress).call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n         _childSavings[_child].amount = 0;\n          _childSavings[_child].targetChild = 0;\n\n    }\n\n    function depositChildSavingsReg(uint256 _age, address _father) external payable  {\n        ChildSavings storage savings = _childSavings[msg.sender];\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n        // uint256 currentTimeStap = block.timestamp;\n        // uint256 getPay = currentTimeStap + _age * 365 * 24 * 60 * 60;\n        savings.targetChild = _age;\n        savings.childAge =_age;\n        savings.amount += msg.value;\n        savings.childAddress = payable (msg.sender);\n        savings.fatherAddress = _father;\n        // savings.canWithdraw = getPay;\n        savings.deposited = true;\n\n        // (bool sent, ) = address(this).call{value: _amount}(\"\");\n        // require(sent, \"Failed to send Ether\");\n    }\n\n    function saveMoreForChild(address _childAddress) external payable  {\n        ChildSavings storage savings = _childSavings[_childAddress];\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n        savings.amount += msg.value;\n    }\n\n    enum SavingsStatus {\n        INITIATESAVING,\n        INPROGRESS,\n        TARGETREACHED\n    }\n\n    struct Savings {\n        address payable owner;\n        uint256 savingsAmount;\n        uint256 target;\n        uint256 startDate;\n        uint256 endDate;\n        string purpose;\n        bool isTime;\n        bool forceWithdraw;\n        bool inSaving;\n        SavingsStatus savingStatus;\n        uint256 nonce;\n    }\n\n    mapping  (uint256 => Savings) public  _savings;\n    //1717926407\n\n    function initialSaving(uint256 _target, string memory _purpose, uint256 _targetAmount) public {\n        Savings storage save = _savings[savinsLen++];\n        uint256 target = (_target * 24 * 60 * 60);\n        save.owner = payable (msg.sender);\n        save.startDate = block.timestamp;\n        save.endDate = block.timestamp + target;\n        save.purpose = _purpose;\n        save.isTime = false;\n        save.forceWithdraw = false;\n        save.inSaving = false;\n        save.savingStatus = SavingsStatus.INITIATESAVING;\n        save.nonce = savinsLen;\n        save.target = _targetAmount;\n        // savinsLen++;\n\n    }\n\n    function depositSave(uint256 _savinsLen) public payable  {\n        require(_savings[_savinsLen].owner == msg.sender, \"You can't initial deposit\" );\n        Savings storage save = _savings[_savinsLen];\n        TxHistory storage txHistory = _txHistory[txHistoryLen][save.owner];\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n\n        save.savingsAmount += msg.value;\n        txHistory.amount += msg.value;\n        save.savingStatus = SavingsStatus.INPROGRESS;\n        txHistory.savingsNonce = _savinsLen;\n        txHistory.owner = save.owner;\n        txHistory.time = block.timestamp;\n        txHistory.purpose = save.purpose;\n        txHistoryLen++;\n\n        // (bool sent, ) = address(this).call{value: _depositAmount}(\"\");\n        // require(sent, \"Failed to send Ether\");\n    }\n    \n    function targetReach(uint256 _savinsLen) public {\n        require(msg.sender == _savings[_savinsLen].owner, \"You dont have account initial withdraw\" );\n        Savings storage save = _savings[_savinsLen];\n         require(save.target >= save.savingsAmount, \"The target must reach before you can withdraw \");\n        uint256 amount = save.target;\n\n        (bool sent, ) = payable(save.owner).call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n        save.target = 0;\n        save.savingsAmount = 0;\n        save.savingStatus = SavingsStatus.TARGETREACHED;\n    }\n    \n    function forceWithdraw() public {}\n\n    \n\n    // Function to receive Ether. msg.data must be empty\n    // receive() external payable {\n    //     emit Received(msg.sender, msg.value);\n    // }\n\n    receive() external payable {}\n\n        fallback() external payable {}\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}